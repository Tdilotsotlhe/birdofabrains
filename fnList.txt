IQueryable<U> LoadTransactions(int bucketID);
IQueryable<U> LoadTransactions(int transactionTypeID, int entityID, int quoteSubAccountID, int bucketID, double amount);
IQueryable<U> Search(Func<T, bool> filter);
IEnumerable<TransactionDto> GetTransactionsByClientImportFileID(int clientImportFileID);
IEnumerable<TransactionDto> GetManualTransactions(int bucketID);
IQueryable<TransactionDto> GetByBankAccountTransactionID(int bankAccountTransactionID);
NotAuthorizedDto LoadNotAuthorizedTransactionsForLoggedInUser();
List<TransactionDto> LoadTransactionsForBusinessEvent(int businessEventTaskID, ClassTypeEnum classType = ClassTypeEnum.ClientImportFile);
TransactionSearchDto SearchTransactions(TransactionSearchCriteriaDto dto);
bool IsCreditItemLimitExceeded(TransactionDto dto);
bool IsDebitItemLimitExceeded(TransactionDto dto);
TransactionDocDto LoadTransactionDocument(int id);
TransactionDetail LoadTransactionDetails(int transactionID);
TransactionRecallInfoDto GetRecallInfo(int transactionId);
bool IsPossibleDuplicatePayment(int bucketID, int entityID, string accountNumber, double amount);
bool IsDuplicatePayment(TransactionDto dto);
bool IsDuplicateCollection(TransactionDto dto);
bool DuplicatePaymentAmount(TransactionDto dto);
RatiosDto IsMaxPaymentRatioExceeded(double aggregateExpectedRatio, double aggregateProcessedRatio, double itemExpectedRatio, double itemProcessedRatio, int transactionSubTypeID, int transactionTypeID, int transactionStatusID, double amount, int bucketID);
T GetByClassTypeID(int classTypeID, int id);
bool PreviousDebitOrderRule(TransactionDto dto);
bool UnpaidDebitOrderRule(TransactionDto dto);
bool NegativeBalanceAllowedRule(TransactionDto dto);
bool NegativeBalanceNotAllowedRule(TransactionDto dto);
bool IsDuplicateAccountRule(TransactionDto dto);
bool IsNegativeExpectedBalance(U dto);
BucketBalanceTotals BucketTotals(int bucketID);
IEnumerable<Transaction> GetTransactionByBucket(int bucketID);
BucketBalanceTotals BucketTotals(IEnumerable<BucketTotalDto> bucketTotals);
TransactionDto[] SaveToFtp(ImportPaymentFileItem importPaymentFileItem, int clientImportFileID, List<TransactionDto> transactions);
Task<IEnumerable<dynamic>> GetClientTransactions(ClientTransactionSearchDto searchCriteria);
U SaveAllocatedTransactions(U dto);
U UpdateTransaction(U dto);
U SaveLinkedTransactions(U dto);
Task<string> GetLinkedTransactions(int bankAccountTransactionID);
Bucket GetBucket(int bucketID);
QuoteSubAccount GetSubAccount(int quoteSubAccountID);
QuoteInterestCalculationGroup GetInterestGroup(int quoteInterestCalculationGroupID);
TransactionDto SaveToImport(TransactionDto dto);
IEnumerable<U> GetTransactionByClientImportFile(int clientImportFileID);
Task<NotAuthorizedDto> GetLoadNotAuthorizedTransactionsForImport();
Task<NotAuthorizedDto> GetLoadNotAuthorizedTransactionsForTransactions();
Task<NotAuthorizedDto> GetLoadNotAuthorizedTransactionsForJournals();
Task<string> GetTransactionAuthLookups();
string LoadTransactionsForBusinessEvent2(int businessEventTaskID, ClassTypeEnum classType = ClassTypeEnum.ClientImportFile);
List<U> GetTransactionsWithAuth(int transactionID);
List<U> GetTransactionByFileWithAuth(int clientImportFileID);
List<TransactionDto> NegativeBalanceRule(List<TransactionDto> transactions);
bool IsUnNominatedNonPremiumPayment(TransactionDto dto);
bool IsRejectedPastActionDatePaymentTicked(TransactionDto dto);
bool CheckIsFintegrateTransaction(int quoteInterestCalculationGroupID);
bool IsRejectedPastActionDateCollectionTicked(TransactionDto dto);
TransactionDashboard GetDashboardReport(DateTime? actionDate);